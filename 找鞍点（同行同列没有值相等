/*虽然我本来也是想先找出最大值再判断是不是最小值，
但我不知道怎么拿着已有的最大值去对应的列里判断，
只好也单独找一遍最小值，
我本来还想既然在找最大值的时候已经历遍过一次数组了能不能同时也把最小值标出来，
但我发现好像方向不同，
总之这个笨笨的方法终于能正常解决没有相等值的问题真的是太好了。*/
/*我有想过拿记录下来的最大值的列坐标去找，
但我不知道在同一列里怎么能又向上比又向下比呢，
如果只往一个方向走，它又没办法循环回到上面去和前面的比较*/
//结果还是重头开始比到尾吗（可以跳过中间相同的，自己




#include<iostream>
using namespace std;
int main() {
	const int h = 100;//最大行数
	int H = 0;//实际行数
	const int l = 100;//最大列数
	int L = 0;//实际列数
	int arry[h][l] = { 0 };
	//确保输入的行数不超过100，确认实际行数
	do {
		cout << "请输入要输入的行总数" << endl;
		cin >> H;
		if (H > h)
		{
			cout << "行数过大，请重新输入一个小于100的数字" << endl;

		}

	} while (H > h);
	//确保输入的列数不超过100，确认实际列数
	do {
		cout << "请输入要输入的列总数" << endl;
		cin >> L;
		if (L > l)
		{
			cout << "列数过大，请重新输入一个小于100的数字" << endl;

		}

	} while (L > l);
	//开始输入数组
	for (int i = 0; i < H; i++)
	{
		for (int j = 0; j < L; j++)
		{
			cout << "请输入第" << i + 1 << "行，第" << j + 1 << "列的值" << endl;
			cin >> arry[i][j];
		}
	}
	//开始寻找
	//先找该行的最大值M，在判断是否为该列的最小值
	int M[h] = { 0 };//存放每一行的最大值
	int MH[h] = { 0 };//存放最大值所在的行号
	int ML[h] = { 0 };//存放最大值所在的列号
	for (int i = 0; i < H; i++)
	{
		M[i] = arry[i][0];
		MH[i] = i;
		ML[i] = 0;
		for (int j = 1; j < L ; j++)
		{

			if (arry[i][j + 1] > M[i]) {
				M[i] = arry[i][j + 1];
				MH[i] = i;
				ML[i] = j + 1;
			}

		}



	}
	int m[l] = { 0 };//存放每一列的最小值
	int mh[l] = { 0 };//存放最小值所在的行号
	int ml[l] = { 0 };//存放最小值所在的列号
	for (int j = 0; j < L; j++)
	{
		m[j] = arry[0][j];
		mh[j] = 0;
		ml[j] = j;
		for (int i = 1; i < H ; i++)
		{

			if (arry[i + 1][j] < m[j]) {
				m[j] = arry[i + 1][j];
				mh[j] = i+1;
				ml[j] = j + 1;
			}

		}



	}
	int flag = 1;//标志是否存在鞍点
	for (int i = 0; i < H; i++)
	{
		for(int j=0;j<L;j++)
		if (MH[i] == mh[j] && ML[i] == ml[j])
		{
			cout << "存在鞍点，鞍点值为：" << M[i] << endl;
			flag = 0;
		}

	}

	if (flag == 1) 
	{
	cout << "不存在鞍点" << endl;
	}







	return 0;

}


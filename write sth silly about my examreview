
在准备傻傻的期末考试，傻傻的写点感想
我不喜欢题库，但顺便思考了一下
{
[].[]e+/-[]
__?A:B;垃圾话}
i++,++i,之类的断句题很讨厌，没有人，不应该刻意写一些歧义话
[*]
但是还是发现了一点有意思的价值->->表达式的双重属性，1.操作，eg调用void函数也是，我们不关它的返回值，而是需要它进行里面的操作
2.值，eg表达式的值，丢在if(中）...进行一个关于这件事，这个操作（完没完成，状态，，，）的判断，用于选择，触发下一步对应的措施

[*]
“后来初始化”的正确说法
实际上，C 语言中 “初始化”只发生在定义时。
定义之后的操作都叫赋值或修改内容。

""--- string
' ' ----char\,'\\','\_ _ _''\x_ _'
单个1，多个双，char,string,要对应，末尾自动补\0要小心，\0是0但含义更明确~NULL，
许多字符串处理和\0有关，是字符串的特征，如果char p[ ]={'a', 'b', 'c'};分别抓到a,b,c3个给自动填的[3]，没有\0专门搞出的非人非鬼的东西
char p[4]={'a', 'b', 'c'};p[3]初始化自动填充的0，可以充当\0
char b[10]; b = "Hello!";
不可以
在 C 语言中，数组名是常量指针，不能作为左值被赋值。不能直接将字符串常量赋值给已定义的数组，必须用 strcpy 或在定义时初始化。
char b[10]; strcpy(b, "Hello!");
可以
strcpy 可以将字符串复制到数组中（前提是目标数组足够大）。
【    C针对字符串，补充了对字符数组初始化的一种新方法，即用字符串常量来使字符数组初始化。
例如：
    char c[]={"c program"};
    或去掉{}写为： char c[]="c program”;
】

strcmp 的比较规则
strcmp(s1, s2) 逐个比较字符（按 ASCII 码大小），直到遇到不同的字符，或者遇到 \0。
比较结果：
如果找到不同字符，返回 s1[i] - s2[i]（可能是正或负）。
如果一直相同直到同时遇到 \0，返回 0。
如果 s1 先到 \0，而 s2 还没结束，则返回负值（'\0' 的 ASCII 是 0，小于任何可见字符）。
(相当于 空格 补0，像连续的一串数一样从高位到低位比大小，高位大的自然的，000的补齐使低位平，站得一样高，一样长，千-千，不会因为长短，千-百）
根据 C 标准，strcmp 返回：
负整数（如果第一个字符串小于第二个）
0（相等）
正整数（如果第一个字符串大于第二个）
但标准没说必须返回差值，只规定正负号表示大小关系。
常见编译器实现：
有些返回差值（如 36）
有些返回 +1、-1（如果只关心符号）
你在你的编译环境运行得到 1，说明它用的是“简化为 ±1”的实现方式（只要第一个大于第二个就返回 1）。


字符串本质是内存中一段以 \0 结尾的字符序列，数组只是常见的一种存储方式。

strlen 从给定的地址开始，逐个字节计数，直到遇到 '\0'（ASCII 0）为止，不包括 '\0'。
cin >> str 不会帮你自动拼接，而是直接从头覆盖
strcat 自动帮你找到末尾并拼接，不需要手动找 \0 的位置。




地址 1004: str[0][4]
地址 1005: str[1][0]  ← 换行了，但内存连续
地址 1006: str[1][1]
...
地址 1019: str[3][4]  ← 最后一个元素
关键：二维数组在内存中是 按行连续存储 的。


[*]
for(int i=0;i<n;i++)
最开始感觉对标什么while结构好像没什么用，后来才发现还是很重要，最开始作业没意识到i++的条件变化是在什么时候变，
导致没有历遍我想要的区域，漏了最后一行（i++,i达成了N,但还没干i=N该干的事就没了）
起始；判断一下（->完成内容）；变化条件

while(){
进入循环前：检查条件是否成立
→ 成立 → 执行循环体
→ 不成立 → 跳过整个 while 循环，执行循环后的语句

每次执行完循环体后（遇到 }），会立即回到 while (条件) 再次检查条件
→ 成立 → 再次执行循环体
→ 不成立 → 退出循环

一旦条件不成立并退出循环后，程序不会自动跳回来
— 即使后面某个时刻条件又成立了（比如循环外部修改了变量），也不会重新进入 while 循环
}写贪吃蛇的时候傻傻以为把这个条件判断的while丢到main就完事了，结果在后面蛇移动的while里，根本不理会之前这个while,执行一下后完全没有用了

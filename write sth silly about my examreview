
在准备傻傻的期末考试，傻傻的写点感想
我不喜欢题库，但顺便思考了一下
{
[].[]e+/-[]
__?A:B;垃圾话}
i++,++i,之类的断句题很讨厌，没有人，不应该刻意写一些歧义话
句读知不知了
[*]
但是还是发现了一点有意思的价值->->表达式的双重属性，1.操作，eg调用void函数也是，我们不关它的返回值，而是需要它进行里面的操作
2.值，eg表达式的值，丢在if(中）...进行一个关于这件事，这个操作（完没完成，状态，，，）的判断，用于选择，触发下一步对应的措施

a % b 的结果满足：
a = (a / b) * b + (a % b)
所以/的取整方式影响了% ，%找的倍数是靠近0一侧的

[*]\
“后来初始化”的正确说法
实际上，C 语言中 “初始化”只发生在定义时。
定义之后的操作都叫赋值或修改内容。

""--- string
' ' ----char\,'\\','\_ _ _'遇到第一个非八进制数字就结束转义序列\018,实际上是、01和8，2个，'\x_ _'
单个1，多个双，char,string,要对应，末尾自动补\0要小心，\0是0但含义更明确~NULL，
许多字符串处理和\0有关，是字符串的特征，如果char p[ ]={'a', 'b', 'c'};分别抓到a,b,c3个给自动填的[3]，没有\0专门搞出的非人非鬼的东西
char p[4]={'a', 'b', 'c'};p[3]初始化自动填充的0，可以充当\0
char b[10]; b = "Hello!";
不可以
在 C 语言中，数组名是常量指针，不能作为左值被赋值。不能直接将字符串常量赋值给已定义的数组，必须用 strcpy 或在定义时初始化。
char b[10]; strcpy(b, "Hello!");
可以
strcpy 可以将字符串复制到数组中（前提是目标数组足够大）。
【    C针对字符串，补充了对字符数组初始化的一种新方法，即用字符串常量来使字符数组初始化。
例如：
    char c[]={"c program"};
    或去掉{}写为： char c[]="c program”;
】
A65-32--a97
strcmp 的比较规则
strcmp(s1, s2) 逐个比较字符（按 ASCII 码大小），直到遇到不同的字符，或者遇到 \0。
比较结果：
如果找到不同字符，返回 s1[i] - s2[i]（可能是正或负）。
如果一直相同直到同时遇到 \0，返回 0。
如果 s1 先到 \0，而 s2 还没结束，则返回负值（'\0' 的 ASCII 是 0，小于任何可见字符）。
(相当于 空格 补0，像连续的一串数一样从高位到低位比大小，高位大的自然的，000的补齐使低位平，站得一样高，一样长，千-千，不会因为长短，千-百）
        '\0'！=	' '
ASCII 值  0	     32
显示效果	不可见（结束符）	可见空白
在 strcmp 中	遇到它就停止比较	正常参与比较
字符串中的地位	终止符	普通字符

根据 C 标准，strcmp 返回：
负整数（如果第一个字符串小于第二个）
0（相等）
正整数（如果第一个字符串大于第二个）
但标准没说必须返回差值，只规定正负号表示大小关系。
常见编译器实现：
有些返回差值（如 36）
有些返回 +1、-1（如果只关心符号）
你在你的编译环境运行得到 1，说明它用的是“简化为 ±1”的实现方式（只要第一个大于第二个就返回 1）。

字符串本质是内存中一段以 \0 结尾的字符序列，数组只是常见的一种存储方式。

strlen 从给定的地址开始，逐个字节计数，直到遇到 '\0'（ASCII 0）为止，不包括 '\0'。
cin >> str 不会帮你自动拼接，而是直接从头覆盖
strcat 自动帮你找到末尾并拼接，不需要手动找 \0 的位置。

char *sp = "right!"; 是让指针指向字符串常量，内容不可修改（尽管语法没加 const，但实质是常量）。

cout << p：如果 p 是 char*，则当作字符串输出，遇到 \0 停止。
cout << *(p+3)：这是输出单个字符，不会当作字符串处理，不会因为它是 \0 就停止整个输出。

str 数组长度是 6（"china" + \0）
p 指向的字符串长度是 5（strlen(p) = 5，不计算 \0）

地址 1004: str[0][4]
地址 1005: str[1][0]  ← 换行了，但内存连续
地址 1006: str[1][1]
...
地址 1019: str[3][4]  ← 最后一个元素
关键：二维数组在内存中是 按行连续存储 的。

auto	                局部（函数内）	        自动（函数调用创建，结束销毁）	无	                随机（未初始化）	局部变量默认用完就丢
static（局部）	        局部（函数内）	        静态（程序开始创建，结束销毁）	无	                自动清零（0）	值不丢
static（全局）	        文件内（从定义到文件尾）	静态	                    内部链接（本文件内）	自动清零（0）	只在本文件
extern	                全局（多个文件）        	静态	                    外部链接（多文件共享）已在别处定义     声明用，不定义
register                局部	                自动		                                    随机（未初始化）
[*]
for(int i=0;i<n;i++,P++(可有多个条件变化）)
最开始感觉对标什么while结构好像没什么用，后来才发现还是很重要，最开始作业没意识到i++的条件变化是在什么时候变，
导致没有历遍我想要的区域，漏了最后一行（i++,i达成了N,但还没干i=N该干的事就没了）
起始；判断一下（->完成内容）；变化条件

while(){
进入循环前：检查条件是否成立
→ 成立 → 执行循环体
→ 不成立 → 跳过整个 while 循环，执行循环后的语句

每次执行完循环体后（遇到 }），会立即回到 while (条件) 再次检查条件
→ 成立 → 再次执行循环体
→ 不成立 → 退出循环

一旦条件不成立并退出循环后，程序不会自动跳回来
— 即使后面某个时刻条件又成立了（比如循环外部修改了变量），也不会重新进入 while 循环
}写贪吃蛇的时候傻傻以为把这个条件判断的while丢到main就完事了，结果在后面蛇移动的while里，根本不理会之前这个while,执行一下后完全没有用了

FILE *fp;                      // 1. 定义文件指针
fp = fopen("文件名", "模式");   // 2. 打开文件（检查是否成功）
// 读写操作...
fclose(fp);                    // 3. 关闭文件

"r"：只读（文件必须存在）
"w"：只写（创建新文件，覆盖旧的）
"a"：追加（在文件末尾添加）
"r+"：读写（文件必须存在）可以读也可以写（常用于修改文件内容）不自动清空文件，写操作会从当前位置覆盖原有内容
"w+"（写读）文件不存在则创建，存在则清空内容先写后读常用（写完后想读需要调整文件指针）
"a+"（追加读）文件不存在则创建写操作永远在文件末尾追加读操作可以从文件任何位置读（通过 fseek 调整）
+ 后面没有东西，它是一个单独的修饰符，不是组合。
函数	作用	例子
fgetc(fp)	读一个字符	ch = fgetc(fp);
fputc(ch, fp)	写一个字符	fputc('A', fp);
fgets(str, n, fp)	读一行（最多 n-1 字符）	fgets(s, 100, fp);
fputs(str, fp)	写字符串	fputs("hello", fp);
fscanf(fp, 格式, 变量)	格式读取	fscanf(fp, "%d", &x);
fprintf(fp, 格式, 变量)	格式写入	fprintf(fp, "%d", x);
fgets 会读入换行符，fscanf 遇空格停止。


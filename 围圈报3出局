#include<iostream>
using namespace std;
int main() {
	int n[100] = { 0};//人的状态，开始时都不在
	int N;//人数
	int peopleleft = 0;
	do {
		cout << "请输入人数(小于100）" << endl;
		cin >> N;
	} while (N > 99||N<=0);
	peopleleft = N;
	for (int i = 1; i <= N; i++) {

		n[i] = 1;
	}//拉n人入圈
	int* out = n;
	//准备开始报数，0->1,1->2,2->3,这样每次都是跨3步是统一的，
//像6，有一个初始的小尾巴--0，这样每一个点前面都有一段空，十分均匀
	// 如果开始为“1”，1->2,2->3,第一次报数时只跨2步，无法与后面的统一，
	// 这样如果人数还小于3就要分类不太好
	//每次报数走一个，n个人，n-1次就够了，似乎不需要2个东西转，可能是为了方便跳过出去的人？
	while (peopleleft > 1) {
		for (int i = 1; i <= 3; i++) {
			out++;
			if (out > n + N)(out = n+1);
			while (*out ==0) { 
				out++;
			if (out > n + N)(out = n+1);
			}
		}
		//走3步，每次遇到跳过的人都要继续走，每次向前都有可能超过，都有可能要回去，迈出的一步仍然有效，所以是回到1
		//1次1步，所以超出就刚好踏向n+1，即1
		//每次都单独判断，每步都有效，比踏完3步再总合有几次无效好，放在一起中间无效的次数不均匀不好记，
		// 而且要确保再补的仍有效好像又是一模一样的问题
		//这样每步都和正常的一样是确实报到了下一个没出去的人
		*out = 0;
		peopleleft--;
		//报到就出去
	}

	for (int j = 1; j <= N; j++)
//看看谁还在
	if(n[j]==1)
	{
		cout << j <<"号留下(从1开始编号）" << endl;
	}
	return 0;

}




#include<iostream>
using namespace std;
int main() {
	int n[100] = { 0};//人的状态，开始时都在
	int N;//人数
	int peopleleft = 0;
	do {
		cout << "请输入人数(小于100）" << endl;
		cin >> N;
	} while (N > 99||N<=0);
	peopleleft = N;
	for (int i = 1; i <= N; i++) {

		n[i] = 1;
	}
	int* number = n;
	
	while (peopleleft > 1) {
		for (int i = 1; i <= 3; i++) {
			number++;
			if (number > n + N)(number = n+1);
			while (*number ==0) { 
				number++;
			if (number > n + N)(number = n+1);
			}
		}
		*number = 0;
		peopleleft--;
	}

	for (int j = 1; j <= N; j++)
	
	if(n[j]==1)
	{
		cout << j <<"号留下(从1开始编号）" << endl;
	}
	return 0;
}
